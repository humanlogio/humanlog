package localproject

import (
	"context"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/go-git/go-billy/v6"
	"github.com/go-git/go-billy/v6/memfs"
	"github.com/google/go-cmp/cmp"
	dashboardv1 "github.com/humanlogio/api/go/svc/dashboard/v1"
	typesv1 "github.com/humanlogio/api/go/types/v1"
	"github.com/humanlogio/humanlog/internal/localstate"
	"github.com/humanlogio/humanlog/internal/pkg/config"
	"github.com/stretchr/testify/require"
	"google.golang.org/protobuf/testing/protocmp"
	"google.golang.org/protobuf/types/known/timestamppb"
)

func TestDashboardLifecycle(t *testing.T) {
	now := time.Date(2025, 10, 21, 10, 56, 42, 123456, time.UTC)
	timeNow := func() time.Time { return now }

	cmpOpts := []cmp.Option{
		protocmp.Transform(),
		protocmp.IgnoreFields(&typesv1.DashboardStatus{}, "created_at", "updated_at"),
		protocmp.IgnoreFields(&typesv1.ProjectStatus{}, "created_at", "updated_at"),
		protocmp.IgnoreFields(&typesv1.DashboardSpec{}, "perses_json"),
	}

	mkPersesJSON := func() []byte {
		return []byte(`{
			"kind": "Dashboard",
			"metadata": {
				"project": "test-project",
				"name": "test-dashboard"
			},
			"spec": {
				"display": {
					"name": "Test Dashboard"
				}
			}
		}`)
	}

	type fileExpectation struct {
		path        string
		shouldExist bool
		contains    []string
	}

	type dashboardExpectation struct {
		projectName string
		id          string
		expected    *typesv1.Dashboard
	}

	type transition struct {
		name            string
		at              time.Duration
		operation       func(context.Context, *testing.T, localstate.DB) error
		expectFile      *fileExpectation
		expectDashboard *dashboardExpectation
	}

	tests := []struct {
		name        string
		initFS      fsState
		initProject *typesv1.ProjectsConfig_Project
		transitions []transition
	}{
		{
			name: "create managed dashboard writes marker",
			initProject: projectConfig("test-project",
				localProjectPointer("project1", "dashboards", "alerts", false),
			),
			transitions: []transition{
				{
					name: "create dashboard",
					operation: func(ctx context.Context, t *testing.T, db localstate.DB) error {
						_, err := db.CreateDashboard(ctx, &dashboardv1.CreateDashboardRequest{
							ProjectName: "test-project",
							Spec: &typesv1.DashboardSpec{
								Name:       "Test Dashboard",
								PersesJson: mkPersesJSON(),
							},
						})
						return err
					},
					expectFile: &fileExpectation{
						path:        "project1/dashboards/test-dashboard.yaml",
						shouldExist: true,
						contains:    []string{"# managed-by: humanlog"},
					},
					expectDashboard: &dashboardExpectation{
						projectName: "test-project",
						id:          dashboardID("test-project", "test-project", "test-dashboard"),
						expected: managedDashboard(
							dashboardID("test-project", "test-project", "test-dashboard"),
							"Test Dashboard",
							"",
							false,
							mkPersesJSON(),
							"project1/dashboards/test-dashboard.yaml",
							now,
							now,
						),
					},
				},
			},
		},
		{
			name: "update managed dashboard preserves marker",
			initProject: projectConfig("test-project",
				localProjectPointer("project1", "dashboards", "alerts", false),
			),
			initFS: fsState{
				"project1/dashboards/test-dashboard.yaml": []byte(`# managed-by: humanlog
kind: Dashboard
metadata:
  project: test-project
  name: test-dashboard
spec:
  display:
    name: Original Name
  panels: {}
  layouts: []
  duration: 0s
`),
			},
			transitions: []transition{
				{
					name: "update dashboard",
					operation: func(ctx context.Context, t *testing.T, db localstate.DB) error {
						_, err := db.UpdateDashboard(ctx, &dashboardv1.UpdateDashboardRequest{
							ProjectName: "test-project",
							Id:          dashboardID("test-project", "test-project", "test-dashboard"),
							Spec: &typesv1.DashboardSpec{
								Name:       "Updated Name",
								PersesJson: mkPersesJSON(),
							},
						})
						return err
					},
					expectFile: &fileExpectation{
						path:        "project1/dashboards/test-dashboard.yaml",
						shouldExist: true,
						contains:    []string{"# managed-by: humanlog", "Updated Name"},
					},
				},
			},
		},
		{
			name: "user can edit generated dashboard by setting is_readonly=false",
			initProject: projectConfig("test-project",
				localProjectPointer("project1", "dashboards", "alerts", false),
			),
			initFS: fsState{
				"project1/dashboards/generated.yaml": []byte(`# Generated by Terraform
# DO NOT EDIT
kind: Dashboard
metadata:
  project: test-project
  name: generated
spec:
  display:
    name: Generated Dashboard
  panels: {}
  layouts: []
  duration: 0s
`),
			},
			transitions: []transition{
				{
					name: "update with is_readonly=false succeeds",
					operation: func(ctx context.Context, t *testing.T, db localstate.DB) error {
						_, err := db.UpdateDashboard(ctx, &dashboardv1.UpdateDashboardRequest{
							ProjectName: "test-project",
							Id:          dashboardID("test-project", "test-project", "generated"),
							Spec: &typesv1.DashboardSpec{
								Name:       "Modified",
								IsReadonly: false,
								PersesJson: mkPersesJSON(),
							},
						})
						return err
					},
					expectFile: &fileExpectation{
						path:        "project1/dashboards/generated.yaml",
						shouldExist: true,
						contains:    []string{"# managed-by: humanlog", "# humanlog.is_readonly: false", "Modified"},
					},
				},
			},
		},
		{
			name: "delete managed dashboard removes file",
			initProject: projectConfig("test-project",
				localProjectPointer("project1", "dashboards", "alerts", false),
			),
			initFS: fsState{
				"project1/dashboards/test-dashboard.yaml": []byte(`# managed-by: humanlog
kind: Dashboard
metadata:
  project: test-project
  name: test-dashboard
spec:
  panels: {}
  layouts: []
  duration: 0s
`),
			},
			transitions: []transition{
				{
					name: "delete dashboard",
					operation: func(ctx context.Context, t *testing.T, db localstate.DB) error {
						_, err := db.DeleteDashboard(ctx, &dashboardv1.DeleteDashboardRequest{
							ProjectName: "test-project",
							Id:          dashboardID("test-project", "test-project", "test-dashboard"),
						})
						return err
					},
					expectFile: &fileExpectation{
						path:        "project1/dashboards/test-dashboard.yaml",
						shouldExist: false,
					},
				},
			},
		},
		{
			name: "discover managed dashboard has managed origin",
			initProject: projectConfig("test-project",
				localProjectPointer("project1", "dashboards", "alerts", false),
			),
			initFS: fsState{
				"project1/dashboards/managed.yaml": []byte(`# managed-by: humanlog
kind: Dashboard
metadata:
  project: test-project
  name: managed
spec:
  display:
    name: Managed Dashboard
  panels: {}
  layouts: []
  duration: 0s
`),
			},
			transitions: []transition{
				{
					name: "list dashboards",
					expectDashboard: &dashboardExpectation{
						projectName: "test-project",
						id:          dashboardID("test-project", "test-project", "managed"),
						expected: managedDashboard(
							dashboardID("test-project", "test-project", "managed"),
							"Managed Dashboard",
							"",
							false,
							nil,
							"project1/dashboards/managed.yaml",
							now,
							now,
						),
					},
				},
			},
		},
		{
			name: "discover generated dashboard with Generated by marker",
			initProject: projectConfig("test-project",
				localProjectPointer("project1", "dashboards", "alerts", true),
			),
			initFS: fsState{
				"project1/dashboards/terraform.yaml": []byte(`# Generated by Terraform
kind: Dashboard
metadata:
  project: test-project
  name: terraform
spec:
  display:
    name: Terraform Dashboard
  panels: {}
  layouts: []
  duration: 0s
`),
			},
			transitions: []transition{
				{
					name: "list dashboards",
					expectDashboard: &dashboardExpectation{
						projectName: "test-project",
						id:          dashboardID("test-project", "test-project", "terraform"),
						expected: generatedDashboard(
							dashboardID("test-project", "test-project", "terraform"),
							"Terraform Dashboard",
							"",
							true,
							nil,
							"project1/dashboards/terraform.yaml",
							`Contains "# Generated by Terraform"`,
							now,
							now,
						),
					},
				},
			},
		},
		{
			name: "discover generated dashboard with DO NOT EDIT marker",
			initProject: projectConfig("test-project",
				localProjectPointer("project1", "dashboards", "alerts", true),
			),
			initFS: fsState{
				"project1/dashboards/codegen.yaml": []byte(`# DO NOT EDIT
kind: Dashboard
metadata:
  project: test-project
  name: codegen
spec:
  panels: {}
  layouts: []
  duration: 0s
`),
			},
			transitions: []transition{
				{
					name: "list dashboards",
					expectDashboard: &dashboardExpectation{
						projectName: "test-project",
						id:          dashboardID("test-project", "test-project", "codegen"),
						expected: generatedDashboard(
							dashboardID("test-project", "test-project", "codegen"),
							"codegen",
							"",
							true,
							nil,
							"project1/dashboards/codegen.yaml",
							`Contains "# DO NOT EDIT"`,
							now,
							now,
						),
					},
				},
			},
		},
		{
			name: "discover generated dashboard with @generated marker",
			initProject: projectConfig("test-project",
				localProjectPointer("project1", "dashboards", "alerts", true),
			),
			initFS: fsState{
				"project1/dashboards/auto.yaml": []byte(`# @generated
kind: Dashboard
metadata:
  project: test-project
  name: auto
spec:
  panels: {}
  layouts: []
  duration: 0s
`),
			},
			transitions: []transition{
				{
					name: "list dashboards",
					expectDashboard: &dashboardExpectation{
						projectName: "test-project",
						id:          dashboardID("test-project", "test-project", "auto"),
						expected: generatedDashboard(
							dashboardID("test-project", "test-project", "auto"),
							"auto",
							"",
							true,
							nil,
							"project1/dashboards/auto.yaml",
							`Contains "# @generated"`,
							now,
							now,
						),
					},
				},
			},
		},
		{
			name: "managed dashboard defaults to writable",
			initProject: projectConfig("test-project",
				localProjectPointer("project1", "dashboards", "alerts", false),
			),
			initFS: fsState{
				"project1/dashboards/managed.yaml": []byte(`# managed-by: humanlog
kind: Dashboard
metadata:
  project: test-project
  name: managed
spec:
  display:
    name: Managed Dashboard
  panels: {}
  layouts: []
  duration: 0s
`),
			},
			transitions: []transition{
				{
					name: "get dashboard",
					expectDashboard: &dashboardExpectation{
						projectName: "test-project",
						id:          dashboardID("test-project", "test-project", "managed"),
						expected: managedDashboard(
							dashboardID("test-project", "test-project", "managed"),
							"Managed Dashboard",
							"",
							false,
							nil,
							"project1/dashboards/managed.yaml",
							now,
							now,
						),
					},
				},
			},
		},
		{
			name: "generated dashboard defaults to readonly",
			initProject: projectConfig("test-project",
				localProjectPointer("project1", "dashboards", "alerts", false),
			),
			initFS: fsState{
				"project1/dashboards/generated.yaml": []byte(`# Generated by tool
kind: Dashboard
metadata:
  project: test-project
  name: generated
spec:
  display:
    name: Generated Dashboard
  panels: {}
  layouts: []
  duration: 0s
`),
			},
			transitions: []transition{
				{
					name: "get dashboard",
					expectDashboard: &dashboardExpectation{
						projectName: "test-project",
						id:          dashboardID("test-project", "test-project", "generated"),
						expected: generatedDashboard(
							dashboardID("test-project", "test-project", "generated"),
							"Generated Dashboard",
							"",
							true,
							nil,
							"project1/dashboards/generated.yaml",
							`Contains "# Generated by tool"`,
							now,
							now,
						),
					},
				},
			},
		},
		{
			name: "managed dashboard with explicit is_readonly=true",
			initProject: projectConfig("test-project",
				localProjectPointer("project1", "dashboards", "alerts", false),
			),
			initFS: fsState{
				"project1/dashboards/readonly.yaml": []byte(`# managed-by: humanlog
# humanlog.is_readonly: true
kind: Dashboard
metadata:
  project: test-project
  name: readonly
spec:
  display:
    name: Readonly Dashboard
  panels: {}
  layouts: []
  duration: 0s
`),
			},
			transitions: []transition{
				{
					name: "get dashboard",
					expectDashboard: &dashboardExpectation{
						projectName: "test-project",
						id:          dashboardID("test-project", "test-project", "readonly"),
						expected: managedDashboard(
							dashboardID("test-project", "test-project", "readonly"),
							"Readonly Dashboard",
							"",
							true,
							nil,
							"project1/dashboards/readonly.yaml",
							now,
							now,
						),
					},
				},
			},
		},
		{
			name: "managed dashboard with explicit is_readonly=false",
			initProject: projectConfig("test-project",
				localProjectPointer("project1", "dashboards", "alerts", false),
			),
			initFS: fsState{
				"project1/dashboards/writable.yaml": []byte(`# managed-by: humanlog
# humanlog.is_readonly: false
kind: Dashboard
metadata:
  project: test-project
  name: writable
spec:
  display:
    name: Writable Dashboard
  panels: {}
  layouts: []
  duration: 0s
`),
			},
			transitions: []transition{
				{
					name: "get dashboard",
					expectDashboard: &dashboardExpectation{
						projectName: "test-project",
						id:          dashboardID("test-project", "test-project", "writable"),
						expected: managedDashboard(
							dashboardID("test-project", "test-project", "writable"),
							"Writable Dashboard",
							"",
							false,
							nil,
							"project1/dashboards/writable.yaml",
							now,
							now,
						),
					},
				},
			},
		},
		{
			name: "dashboard with unrelated comments ignored",
			initProject: projectConfig("test-project",
				localProjectPointer("project1", "dashboards", "alerts", false),
			),
			initFS: fsState{
				"project1/dashboards/commented.yaml": []byte(`# This is an awesome dashboard
# Created by the team
# Version 1.0
kind: Dashboard
metadata:
  project: test-project
  name: commented
spec:
  display:
    name: Commented Dashboard
  panels: {}
  layouts: []
  duration: 0s
`),
			},
			transitions: []transition{
				{
					name: "get dashboard",
					expectDashboard: &dashboardExpectation{
						projectName: "test-project",
						id:          dashboardID("test-project", "test-project", "commented"),
						expected: generatedDashboard(
							dashboardID("test-project", "test-project", "commented"),
							"Commented Dashboard",
							"",
							true,
							nil,
							"project1/dashboards/commented.yaml",
							"No humanlog metadata or generation markers found",
							now,
							now,
						),
					},
				},
			},
		},
		{
			name: "dashboard with both humanlog and unrelated comments",
			initProject: projectConfig("test-project",
				localProjectPointer("project1", "dashboards", "alerts", false),
			),
			initFS: fsState{
				"project1/dashboards/mixed.yaml": []byte(`# This dashboard is maintained by our team
# managed-by: humanlog
# humanlog.is_readonly: false
# Last updated: 2025-01-15
kind: Dashboard
metadata:
  project: test-project
  name: mixed
spec:
  display:
    name: Mixed Comments Dashboard
  panels: {}
  layouts: []
  duration: 0s
`),
			},
			transitions: []transition{
				{
					name: "get dashboard",
					expectDashboard: &dashboardExpectation{
						projectName: "test-project",
						id:          dashboardID("test-project", "test-project", "mixed"),
						expected: managedDashboard(
							dashboardID("test-project", "test-project", "mixed"),
							"Mixed Comments Dashboard",
							"",
							false,
							nil,
							"project1/dashboards/mixed.yaml",
							now,
							now,
						),
					},
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ctx := context.Background()
			fs := memfs.New()

			// Initialize filesystem
			if tt.initFS != nil {
				for path, data := range tt.initFS {
					require.NoError(t, writeFile(fs, path, data))
				}
			}

			// Create config
			cfg := &typesv1.ProjectsConfig{
				Projects: []*typesv1.ProjectsConfig_Project{tt.initProject},
			}

			// Create watch
			db := newWatch(ctx, t, cfg, fs, timeNow)

			// Execute transitions
			for _, trans := range tt.transitions {
				t.Run(trans.name, func(t *testing.T) {
					if trans.operation != nil {
						err := trans.operation(ctx, t, db)
						require.NoError(t, err)
					}

					if trans.expectFile != nil {
						exists, err := fileExists(fs, trans.expectFile.path)
						require.NoError(t, err)
						require.Equal(t, trans.expectFile.shouldExist, exists)

						if trans.expectFile.shouldExist && len(trans.expectFile.contains) > 0 {
							data, err := readFile(fs, trans.expectFile.path)
							require.NoError(t, err)
							for _, substr := range trans.expectFile.contains {
								require.Contains(t, string(data), substr)
							}
						}
					}

					if trans.expectDashboard != nil {
						resp, err := db.GetDashboard(ctx, &dashboardv1.GetDashboardRequest{
							ProjectName: trans.expectDashboard.projectName,
							Id:          trans.expectDashboard.id,
						})
						require.NoError(t, err)
						require.Empty(t, cmp.Diff(trans.expectDashboard.expected, resp.Dashboard, cmpOpts...))
					}
				})
			}
		})
	}
}

type fsState map[string][]byte

// Helper functions

func managedDashboard(
	id string,
	name, desc string,
	isReadonly bool,
	persesJSON []byte,
	path string,
	createdAt, updatedAt time.Time,
) *typesv1.Dashboard {
	return &typesv1.Dashboard{
		Meta: &typesv1.DashboardMeta{
			Id: id,
		},
		Spec: &typesv1.DashboardSpec{
			Name:        name,
			Description: desc,
			IsReadonly:  isReadonly,
			PersesJson:  persesJSON,
		},
		Status: &typesv1.DashboardStatus{
			CreatedAt: timestamppb.New(createdAt),
			UpdatedAt: timestamppb.New(updatedAt),
			Origin: &typesv1.DashboardStatus_Managed{
				Managed: &typesv1.DashboardStatus_ManagedDashboard{
					Path: path,
				},
			},
		},
	}
}

func generatedDashboard(
	id string,
	name, desc string,
	isReadonly bool,
	persesJSON []byte,
	path string,
	detectionReason string,
	createdAt, updatedAt time.Time,
) *typesv1.Dashboard {
	return &typesv1.Dashboard{
		Meta: &typesv1.DashboardMeta{
			Id: id,
		},
		Spec: &typesv1.DashboardSpec{
			Name:        name,
			Description: desc,
			IsReadonly:  isReadonly,
			PersesJson:  persesJSON,
		},
		Status: &typesv1.DashboardStatus{
			CreatedAt: timestamppb.New(createdAt),
			UpdatedAt: timestamppb.New(updatedAt),
			Origin: &typesv1.DashboardStatus_Generated{
				Generated: &typesv1.DashboardStatus_GeneratedDashboard{
					Path:            path,
					DetectionReason: detectionReason,
				},
			},
		},
	}
}

func newWatch(ctx context.Context, t *testing.T, cfg *typesv1.ProjectsConfig, fs billy.Filesystem, timeNow func() time.Time) localstate.DB {
	alertState := localstate.NewMemory().AlertRuleStatusStorage()
	fullCfg := &config.Config{CurrentConfig: &typesv1.LocalhostConfig{
		Runtime: &typesv1.RuntimeConfig{
			ExperimentalFeatures: &typesv1.RuntimeConfig_ExperimentalFeatures{
				Projects: cfg,
			},
		},
	}}
	db, err := internalWatch(ctx, fs, fullCfg, alertState, parseQuery, timeNow)
	require.NoError(t, err)
	return db
}

func writeFile(fs billy.Filesystem, path string, data []byte) error {
	// Create parent directories
	dir := filepath.Dir(path)
	if dir != "." && dir != "/" {
		parts := strings.Split(dir, string(filepath.Separator))
		current := ""
		for _, part := range parts {
			if part == "" {
				continue
			}
			if current == "" {
				current = part
			} else {
				current = filepath.Join(current, part)
			}
			_ = fs.MkdirAll(current, 0755)
		}
	}

	f, err := fs.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()
	_, err = f.Write(data)
	return err
}

func readFile(fs billy.Filesystem, path string) ([]byte, error) {
	f, err := fs.Open(path)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	stat, err := f.Stat()
	if err != nil {
		return nil, err
	}

	buf := make([]byte, stat.Size())
	_, err = f.Read(buf)
	if err != nil {
		return nil, err
	}
	return buf, nil
}

func fileExists(fs billy.Filesystem, path string) (bool, error) {
	_, err := fs.Stat(path)
	if err != nil {
		if os.IsNotExist(err) {
			return false, nil
		}
		return false, err
	}
	return true, nil
}

func TestDashboardSlugValidation(t *testing.T) {
	ctx := context.Background()
	fs := memfs.New()

	cfg := &typesv1.ProjectsConfig{
		Projects: []*typesv1.ProjectsConfig_Project{
			projectConfig("test-project",
				localProjectPointer("project1", "dashboards", "alerts", false),
			),
		},
	}

	db := newWatch(ctx, t, cfg, fs, func() time.Time { return time.Now() })

	// Test that invalid names with dots are rejected
	_, err := db.CreateDashboard(ctx, &dashboardv1.CreateDashboardRequest{
		ProjectName: "test-project",
		Spec: &typesv1.DashboardSpec{
			Name: "Test Dashboard",
			PersesJson: []byte(`{
				"kind": "Dashboard",
				"metadata": {
					"project": "test-project",
					"name": "my.test.dashboard"
				},
				"spec": {
					"display": {
						"name": "Test Dashboard"
					},
					"panels": {},
					"layouts": [],
					"duration": "0s"
				}
			}`),
		},
	})
	require.Error(t, err)
	require.Contains(t, err.Error(), "must only contain alphanumeric characters, underscores, and hyphens")

	// Test that valid names work
	_, err = db.CreateDashboard(ctx, &dashboardv1.CreateDashboardRequest{
		ProjectName: "test-project",
		Spec: &typesv1.DashboardSpec{
			Name: "Test Dashboard",
			PersesJson: []byte(`{
				"kind": "Dashboard",
				"metadata": {
					"project": "test-project",
					"name": "my-test-dashboard"
				},
				"spec": {
					"display": {
						"name": "Test Dashboard"
					},
					"panels": {},
					"layouts": [],
					"duration": "0s"
				}
			}`),
		},
	})
	require.NoError(t, err)

	// Verify the file was created
	exists, err := fileExists(fs, "project1/dashboards/my-test-dashboard.yaml")
	require.NoError(t, err)
	require.True(t, exists, "dashboard file should exist")

	// Verify we can retrieve it by the hash-based ID
	expectedID := dashboardID("test-project", "test-project", "my-test-dashboard")
	resp, err := db.GetDashboard(ctx, &dashboardv1.GetDashboardRequest{
		ProjectName: "test-project",
		Id:          expectedID,
	})
	require.NoError(t, err)
	require.NotNil(t, resp.Dashboard)
	require.Equal(t, expectedID, resp.Dashboard.Meta.Id)
}